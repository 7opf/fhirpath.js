focus: true
tests:
  - desc: '5. Functions'
  - desc: '5.1 Existence'
  - desc: '5.1.1. empty() : boolean'
# Returns true if the input collection is empty ({ }) and false otherwise.

  - desc: '** empty coll'
    expression: Functions.attrempty.empty()
    result: [true]

  - desc: '** not empty coll'
    expression: Functions.attrsingle.empty()
    result: [false]

  - desc: '** empty nothing'
    expression: Functions.nothing.empty()
    result: [true]

  - desc: '5.1.2. not() : boolean'
# Returns true if the input collection evaluates to
# false, and false if it evaluates to true. Otherwise, the result is empty ({
# }):

#  	not
# true

# false

# false

# true

# empty ({ })

# empty ({ })

  - desc: '** not true is false'
    expression: Functions.attrtrue.not()
    result: [false]

  - desc: '** not false is true'
    expression: Functions.attrfalse.not()
    result: [true]

  - desc: '** true with double not is true'
    expression: Functions.attrtrue.not().not()
    result: [true]

  - desc: '** empty coll with not() is empty coll'
    expression: Functions.attrempty.not()
    result: []

  - desc: '** not empty, non-boolean coll with not() is empty'
    expression: Functions.attrdouble.not()
    result: []

  - desc: '** multi-valued boolean coll with not() is empty'
    expression: Functions.attrdouble.not()
    result: []

  - desc: '** not nothing is empty coll'
    expression: Functions.nothing.not()
    result: []


  - desc: '5.1.3. exists([criteria : expression]) : boolean'
#  Returns true if the collection has any elements, and false otherwise. This is the opposite of
# empty(), and as such is a shorthand for empty().not(). If the input collection
# is empty ({ }), the result is false.

  - desc: '** exists for not empty coll should return true'
    expression: Functions.coll1.exists()
    result: [true]


  - desc: '** exists for empty coll should return false'
    expression: Functions.attrempty.exists()
    result: [false]

  - desc: '** exists for undefined coll should return false'
    expression: Functions.nothing.exists()
    result: [false]

# The operator can also take an optional criteria to be applied to the collection prior to the determination of the exists. In this case, the operation is shorthand for where(criteria).exists().

  - desc: '** exists with criteria should work'
    expression: Functions.coll1.coll2.attr.exists($this > 0)
    result: [true]

  - desc: '** exists with criteria should work for empty filtered coll'
    expression: Functions.coll1.coll2.attr.exists($this < 0)
    result: [false]

  - desc: '** exists with criteria should work for not exists coll '
    expression: Functions.nothing.attr.exists($this < 0)
    result: [false]


  - desc: '5.1.4. all(criteria : expression) : boolean'
# Returns true if for every element in the input collection, criteria evaluates to true. Otherwise, the result is
# false. If the input collection is empty ({ }), the result is true.

  - desc: '** all for empty coll is true'
    expression: Functions.attrempty.all($this > 0)
    result: [true]

  - desc: '** all for non-exists coll is true'
    expression: Functions.nothing.all($this > 0)
    result: [true]

  - desc: '** all for evaluations is true'
    expression: Functions.coll1.coll2.attr.all($this > 0)
    result: [true]


  - desc: '** not all evaluations is true'
    expression: Functions.coll1.coll2.attr.all($this = 5)
    result: [false]


  - desc: '5.1.5. allTrue() : boolean'
# Takes a collection of boolean values and returns
# true if all the items are true. If any items are false, the result is false.
# If the input is empty ({ }), the result is true.

  - desc: '** allTrue for empty coll is true'
    expression: Functions.attrempty.allTrue()
    result: [true]

  - desc: '** allTrue for coll with all true items is true'
    expression: Functions.coll1.colltrue.attr.allTrue()
    result: [true]

  - desc: '** allTrue for coll with false value'
    expression: Functions.coll1.collwithfalse.attr.allTrue()
    result: [false]

  - desc: '** allTrue for non exists coll is true'
    expression: Functions.nothing.allTrue()
    result: [true]


  - desc: '5.1.6. anyTrue() : boolean'
# Takes a collection of boolean values and returns
# true if any of the items are true. If all the items are false, or if the input
# is empty ({ }), the result is false.

  - desc: '** anyTrue for empty coll is false'
    expression: Functions.attrempty.anyTrue()
    result: [false]

  - desc: '** anyTrue for non-exists coll is false'
    expression: Functions.nothing.anyTrue()
    result: [false]

  - desc: '** anyTrue for coll with true value'
    expression: Functions.coll1.collwithfalse.attr.anyTrue()
    result: [true]

  - desc: '** anyTrue for coll with all false values'
    expression: Functions.coll1.collfalse.attr.anyTrue()
    result: [false]


  - desc: '5.1.7. allFalse() : boolean'
# Takes a collection of boolean values and returns
# true if all the items are false. If any items are true, the result is false.
# If the input is empty ({ }), the result is true.

  - desc: '** allFalse for empty coll is true'
    expression: Functions.attrempty.allFalse()
    result: [true]

  - desc: '** allFalse for non-exists coll is true'
    expression: Functions.nothing.allFalse()
    result: [true]

  - desc: '** allFalse for coll with all false items is true'
    expression: Functions.coll1.collfalse.attr.allFalse()
    result: [true]

  - desc: '** allFalse for coll with true value'
    expression: Functions.coll1.collwithfalse.attr.allFalse()
    result: [false]


  - desc: '5.1.8. anyFalse() : boolean'
# Takes a collection of boolean values and returns
# true if any of the items are false. If all the items are true, or if the input
# is empty ({ }), the result is false.

  - desc: '** anyFalse for empty coll is false'
    expression: Functions.attrempty.anyFalse()
    result: [false]

  - desc: '** anyFalse for non-exists coll is false'
    expression: Functions.nothing.anyFalse()
    result: [false]

  - desc: '** anyFalse for coll with false value'
    expression: Functions.coll1.collwithfalse.attr.anyFalse()
    result: [true]

  - desc: '** anyFalse for coll with all true values'
    expression: Functions.coll1.colltrue.attr.anyFalse()
    result: [false]

  - desc: 'TODO 5.1.5 - 5.1.8 add test for non-boolean values'


  - desc: '5.1.9. subsetOf(other : collection) : boolean'
# Returns true if all items in the
# input collection are members of the collection passed as the other argument.
# Membership is determined using the equals (=) operation (see below).

# Conceptually, this function is evaluated by testing each element in the input
# collection for membership in the other collection, with a default of true.
# This means that if the input collection is empty ({ }), the result is true,
# otherwise if the other collection is empty ({ }), the result is false.

  - desc: '** if input coll is empty - result of subset is true'
    expression: Functions.attrempty.subsetOf(Functions.attrdouble)
    result: [true]

  - desc: '** if argument coll is empty - result of subset is false'
    expression: Functions.attrdouble.subsetOf(Functions.attrempty)
    result: [false]

  - desc: '** if argument coll isnt exists -  result of subset is false'
    expression: Functions.attrdouble.subsetOf(Functions.attrempty)
    result: [false]

  - desc: '** if input coll is subset of argument coll'
    expression: Functions.attrdouble.subsetOf(Functions.coll1[0].coll2.attr)
    result: [true]

  - desc: '** if input coll isnt subset of argument coll'
    expression: Functions.coll1[0].coll2.attr.subsetOf(Functions.attrdouble)
    result: [false]

  - desc: '** 5.1.10. supersetOf(other : collection) : boolean'
# Returns true if all items in the collection passed as the other argument are members of the input
# collection. Membership is determined using the equals (=) operation (see
# below).

# Note - The following paragraph is from the spec, but the spec is in error.
# Conceptually, this function is evaluated by testing each element in the other
# collection for membership in the input collection, with a default of false.
# This means that if the input collection is empty ({ }), the result is false,
# otherwise if the other collection is empty ({ }), the result is true.

  - desc: '** if argumet coll is empty - result of superset is true'
    expression: Functions.attrdouble.supersetOf(Functions.attrempty)
    result: [true]

  - desc: '** if input coll is empty - result of superset is false'
    expression: Functions.attrempty.supersetOf(Functions.attrdouble)
    result: [false]

  - desc: '** if input coll isnt exists and argument is non-empty, result of superset is false'
    expression: Functions.attrempty.supersetOf(Functions.attrdouble)
    result: [false]

  - desc: '** if argument coll is superset of input coll result is true'
    expression: Functions.coll1[0].coll2.attr.supersetOf(Functions.attrdouble)
    result: [true]

  - desc: '** if argument coll isnt superset of input coll result is false'
    expression: Functions.attrdouble.supersetOf(Functions.coll1[0].coll2.attr)
    result: [false]


  - desc: '5.1.11. isDistinct() : boolean'
# Returns true if all the items in the input
# collection are distinct. To determine whether two items are distinct, the
# equals (=) operator is used, as defined below.

# Conceptually, this function is shorthand for a comparison of the count() of
# the input collection against the count() of the distinct() of the input
# collection:

# X.count() = X.distinct().count() This means that if the input collection is
# empty ({ }), the result is true.

  - desc: '** isDistinct of empty input coll is true'
    expression: Functions.attrempty.isDistinct()
    result: [true]

  - desc: '** isDistinct of non-exists coll is true'
    expression: Functions.nothing.isDistinct()
    result: [true]

  - desc: '** isDistinct of distinct coll'
    expression: Functions.coll1.coll2.attr.isDistinct()
    result: [true]

  - desc: '** isDistinct of coll with same values'
    expression: Functions.coll1.collfalse.attr.isDistinct()
    result: [false]


  - desc: '5.1.12. distinct() : collection'
# Returns a collection containing only the
# unique items in the input collection. To determine whether two items are the
# same, the equals (=) operator is used, as defined below.

# If the input collection is empty ({ }), the result is empty.

  - desc: '** distinct of empty coll is empty'
    expression: Functions.attrempty.distinct()
    result: []

  - desc: '** distinct of non-exists coll is empty'
    expression: Functions.nothing.distinct()
    result: []

  - desc: '** distinct of coll with same values'
    expression: Functions.coll1[2].colltrue.attr.distinct()
    result: [true]

  - desc: '** distinct of coll with different values'
    expression: Functions.coll1[0].coll2.attr.distinct()
    result: [1, 2, 3]


  - desc: '5.1.13. count() : integer'
# Returns a collection with a single value which is
# the integer count of the number of items in the input collection. Returns 0
# when the input collection is empty.

  - desc: '** count'
    expression: Functions.coll1.count()
    result: [6]

  - desc: '** nested count'
    expression: Functions.coll1.coll2.count()
    result: [5]

  - desc: '** nested count (alternative)'
    expression: Functions.coll1[0].coll2.count()
    result: [3]

  - desc: '** 0 if nothing'
    expression: Functions.ups.count()
    result: [0]


  - desc: '5.2. Filtering and projection'
  - desc: '5.2.1. where(criteria : expression) : collection'
# Returns a collection containing only those elements in the input collection for which the stated criteria expression evaluates to true. Elements for which the expression evaluates to false or empty ({ }) are not included in the result.

  - desc: '** filter coll of numbers'
    expression: Functions.coll1.coll2.attr.where($this > 2)
    result: [3, 4, 5]

  - desc: '** filter coll with empty coll result'
    expression: Functions.coll1.coll2.attr.where($this = 0)
    result: []

# If the input collection is emtpy ({ }), the result is empty.

  - desc: '** filter empty coll'
    expression: Functions.attrempty.where($this > 0)
    result: []

  - desc: '** filter non-exists coll'
    expression: Functions.nothing.where($this < 0)
    result: []

  - desc: '5.2.2. select(projection: expression) : collection'
# Evaluates the projection expression for each item in the input collection. The result of each evaluation is added to the output collection. If the evaluation results in a collection with multiple items, all items are added to the output collection (collections resulting from evaluation of projection are flattened). This means that if the evaluation for an element results in the empty collection ({ }), no element is added to the result, and that if the input collection is empty ({ }), the result is empty as well.

  - desc: '** simple select'
    expression: Functions.coll1.coll2.select(attr)
    result: [1, 2, 3, 4, 5]

  - desc: '** select 2'
    expression: Functions.coll1.select(colltrue | collfalse).attr
    result: [true, true, true, false, false]

  - desc: '** select 3'
    expression: Functions.coll1.select(colltrue.attr | collfalse.attr)
    result: [true, true, true, false, false]

  - desc: '** select on empty coll is empty'
    expression: Functions.attrempty.select(nothing)
    result: []


  - desc: '5.2.3. repeat(projection: expression) : collection'
# A version of select that will repeat the projection and add it to the output collection, as long as the projection yields new items (as determined by the equals (=) operator).

# This operation can be used to traverse a tree and selecting only specific children:

# ValueSet.expansion.repeat(contains)
# Will repeat finding children called contains, until no new nodes are found.

# Questionnaire.repeat(group | question).question
# Will repeat finding children called group or question, until no new nodes are found.

# Note that this is slightly different from:

# Questionnaire.descendants().select(group | question)
# which would find any descendants called group or question, not just the ones nested inside other group or question elements.
  - desc: '* traverse tree'
  - desc: '** find all true values in nested coll'
  - desc: 'TODO FIX INF LOOP'
    # expression: Functions.coll1.colltrue.repeat(true)
    # result: [true, true, true]

  - desc: '** find non-exists value'
    expression: Functions.coll1.repeat(nothing)
    result: []


  - desc: '5.2.4. ofType(type : identifier) : collection'
# Returns a collection that contains all items in the input collection that are of the given type or a subclass thereof. If the input collection is empty ({ }), the result is empty.
  - desc: '** empty input coll'
    expression: Functions.attrempty.ofType(string)
    result: []


  - desc: '5.3. Subsetting 5.3.1. [ index : integer ] : collection'
# The indexer operation
# returns a collection with only the index-th item (0-based index). If the input
# collection is empty ({ }), or the index lies outside the boundaries of the
# input collection, an empty collection is returned.

# Example:

# Patient.name[0]

  - desc: '** [index]'
    expression: Functions.coll1[1].coll2[0].attr
    result: [4]

  - desc: '** [big index]'
    expression: Functions.coll1[100].coll2[0].attr
    result: []

  - desc: '5.3.2. single() : collection'
# Will return the single item in the input if there
# is just one item. If the input collection is empty ({ }), the result is empty.
# If there are multiple items, an error is signaled to the evaluation
# environment. This operation is useful for ensuring that an error is returned
# if an assumption about cardinality is violated at run-time.
  - desc: '** single'
    expression: Functions.attrsingle.single()
    result: [1]

  - desc: '** single on nothing'
    expression: Functions.ups.single()
    result: []

  - desc: '** single on empty'
    expression: Functions.attrempty.single()
    result: []

  - desc: '** single on many'
    expression: Functions.attrdouble.single()
    result:
      $status: error
      $error: Expected single

  - desc: '5.3.3. first() : collection'
# Returns a collection containing only the first
# item in the input collection. This function is equivalent to item(0), so it
# will return an empty collection if the input collection has no items.
  - desc: '** first'
    expression: Functions.attrdouble.first()
    result: [1]

  - desc: '** first nothing'
    expression: Functions.nothing.first()
    result: []

  - desc: '5.3.4. last() : collection'
# Returns a collection containing only the last item
# in the input collection. Will return an empty collection if the input
# collection has no items.

  - desc: '** last'
    expression: Functions.attrdouble.last()
    result: [2]

  - desc: '** last (alternative)'
    expression: Functions.attrsingle.last()
    result: [1]

  - desc: '** last on empty'
    expression: Functions.attrempty.last()
    result: []

  - desc: '** last nothing'
    expression: Functions.nothing.last()
    result: []

  - desc: '5.3.5. tail() : collection'
# Returns a collection containing all but the first
# item in the input collection. Will return an empty collection if the input
# collection has no items, or only one item.

  - desc: '** tail'
    expression: Functions.attrdouble.tail()
    result: [ 2 ]

  - desc: '** tail on one'
    expression: Functions.attrsingle.tail()
    result:  [ ]

  - desc: '** tail on empty'
    expression: Functions.attrempty.tail()
    result: []

  - desc: '** tail nothing'
    expression: Functions.nothing.tail()
    result: []

  - desc: '** tail (alternative)'
    expression: Functions.coll1.coll2.attr.tail()
    result: [2, 3, 4, 5]


  - desc: '5.3.6. skip(num : integer) : collection'
# Returns a collection containing all
# but the first num items in the input collection. Will return an empty
# collection if there are no items remaining after the indicated number of items
# have been skipped, or if the input collection is empty. If num is less than or
# equal to zero, the input collection is simply returned.
  - desc: '** skip'
    expression: Functions.attrdouble.skip(1)
    result: [2]

  - desc: '** skip 2'
    expression: Functions.attrsingle.skip(1)
    result: []

  - desc: '** skip 3'
    expression: Functions.coll1.coll2.attr.skip(3)
    result: [4, 5]

  - desc: '** skip 4'
    expression: Functions.coll1.coll2.attr.skip(4)
    result: [5]

  - desc: '** skip 5'
    expression: Functions.coll1.coll2.attr.skip(5)
    result: []

  - desc: '** skip 6'
    expression: Functions.coll1.coll2.attr.skip(6)
    result: []


  - desc: '5.3.7. take(num : integer) : collection'
# Returns a collection containing the
# first num items in the input collection, or less if there are less than num
# items. If num is less than or equal to 0, or if the input collection is empty
# ({ }), take returns an empty collection.

  - desc: '** take'
    expression: Functions.attrdouble.take(1)
    result: [ 1 ]

  - desc: '** take 2'
    expression: Functions.attrdouble.take(2)
    result: [ 1, 2 ]

  - desc: '** take more then has'
    expression: Functions.attrsingle.take(2)
    result:  [ 1 ]

  - desc: '** take on empty'
    expression: Functions.attrempty.take(1)
    result: []

  - desc: '** take nothing'
    expression: Functions.nothing.take(2)
    result: []

  - desc: '** take 3'
    expression: Functions.coll1.coll2.attr.take(3)
    result: [1, 2, 3]

  - desc: '** take 4'
    expression: Functions.coll1.coll2.attr.take(4)
    result: [1, 2, 3, 4]

  - desc: '** take 5'
    expression: Functions.coll1.coll2.attr.take(5)
    result: [1, 2, 3, 4, 5]


  - desc:  '5.4. Combining'
  - desc: '5.4.1. | (union collections)'
# Merge the two collections into a single collection, eliminating any duplicate values (using equals (=)) to determine equality). Unioning an empty collection to a non-empty collection will return the non-empty collection with duplicates eliminated. There is no expectation of order in the resulting collection.

  - desc: '** Unioning empty coll with non-exists coll  is empty coll'
    expression: Functions.coll1.nothing | Functions.attrempty
    result: []

  - desc: '** Unioning empty coll with non-distinct coll is coll without duplicates'
    expression: Functions.attrempty | Functions.coll1.colltrue.attr
    result: [true]

  - desc: '** Unioning colls'
    expression: Functions.attrdouble | Functions.coll1.colltrue.attr
    result: [1, 2, true]

  - desc: '** Unioning colls 2'
    expression: Functions.attrdouble | Functions.coll1.coll2.attr
    result: [1, 2, 3, 4, 5]


  - desc: '5.4.2. combine(other : collection) : collection'
# Merge the input and other collections into a single collection without eliminating duplicate values. Combining an empty collection with a non-empty collection will return the non-empty collection. There is no expectation of order in the resulting collection.

  - desc: '** Combine empty coll with non-exists coll is empty coll'
    expression: Functions.attrempty.combine(Functions.nothing)
    result: []

  - desc: '** Combine empty coll with non-empty coll'
    expression: Functions.attrempty.combine(Functions.coll1.colltrue.attr)
    result: [true, true, true]

  - desc: '** Combine colls'
    expression: Functions.attrdouble.combine(Functions.coll1.colltrue.attr)
    result: [1, 2, true, true, true]

  - desc: '** Combine colls 2'
    expression: Functions.attrdouble.combine(Functions.coll1.coll2.attr)
    result: [1, 2, 1, 2, 3, 4, 5]

  - desc: '5.5. Conversion'
  - desc: '5.5.1. iif(criterium: expression, true-result: collection [, otherwise-result:
 collection]) : collection'
# If criterium is true, the function returns the value
# of true-result parameter.

# If criterium is false or an empty collection, the function returns
# otherwise-result, unless the optional otherwise-expression is not given, in
# which case the function returns an empty collection.

  - desc: '** boolean - true'
    expression: 'true'
    result: [true]

  - desc: '** boolean - false'
    expression: 'false'
    result: [false]

  - desc: '** iif'
    expression: Functions.iif(true, 'a', 'b')
    result: ['a']

  - desc: '** iif 2'
    expression: Functions.iif(false, 'a', 'b')
    result: ['b']

  - desc: '** iif 3'
    expression: Functions.iif(coll1[0].coll2[0].attr = 1, coll1[0].coll2[0].attr, coll1[0].coll2[1].attr)
    result: [1]


  - desc: '5.5.2. toInteger() : integer'
    # If the input collection contains a single item, this functio# n will return a single integer if:
    # the item in the input collection is an integer
    # the item in the input collection is a string and is convertible to an integer
    # the item is a boolean, where true results in a 1 and false results in a 0.
    # If the item is not one the above types, the evaluation of the expression will end and signal an error to the calling environment.
    # If the item is a string, but the string is not convertible to an integer (using the regex format (\\+|-)?\d+), the evaluation of the expression will end and signal an error to the calling environment.

    # In all other cases, the function will return an empty collection.
  - desc: '** Bool to int'
    expression: Functions.attrtrue.toInteger()
    results: [1]

  - desc: '5.5.3. toDecimal() : decimal'
# If the input collection contains a single item, this function will return a single decimal if:
# the item in the input collection is an integer or decimal
# the item in the input collection is a string and is convertible to a decimal
# the item is a boolean, where true results in a 1.0 and false results in a 0.0.
# If the item is not one of the above types, the evaluation of the expression will end and signal an error to the calling environment.
# If the item is a string, but the string is not convertible to a decimal (using the regex format (\\+|-)?\d+('.' \d+)?), the evaluation of the expression will end and signal an error to the calling environment.
# In all other cases, the function will return an empty collection.
  - desc: '** Bool to decimal'
    expression: Functions.attrtrue.toDecimal()
    result: [1.0]


  - desc: '5.5.4. toString() : string'
# If the input collection contains a single item, this function will return a single string if:
# the item in the input collection is a string
# the item in the input collection is an integer, decimal, time or dateTime the output will contain its string representation
# the item is a boolean, where true results in 'true' and false in 'false'.
# If the item is not one of the above types, the evaluation of the expression will end and signal an error to the calling environment.
# The string representation uses the following formats:
# Type	Representation
# boolean
# true or false

# integer
# (\\+|-)?\d+

# decimal
# (\\+|-)?\d+(.\d+)?

# quantity
# (\\+|-)?\d+(.\d+)? '<unit>'

# dateTime
# YYYY-MM-DDThh:mm:ss.fff(+/-)hh:mm

# time
# Thh:mm:ss.fff(+/-)hh:mm

# Note that for partial dates and times, the result will only be specified to the level of precision in the value being converted.
# In all other cases, the function will return an empty collection.

  - desc: '** bool to string'
    expression: Functions.attrtrue.toString()
    result: ['true']


  - desc: '5.6. String Manipulation'
# The functions in this section operate on collections with a single item. If there is more than one item, or an item that is not a string, the evaluation of the expression will end and signal an error to the calling environment.

  - desc: '5.6.1. indexOf(substring : string) : integer'
# If the input collection contains a single item of type string, will return the 0-based index of the first position this substring is found in the input string, or -1 if it is not found. If the substring is an empty string, the function returns 0.
  - desc: '** index of substring'
    expression: Functions.coll1.mixed[2].attr.indexOf('string')
    result: [5]

  - desc: '5.6.2. substring(start : integer [, length : integer]) : string'
# If the input collection contains a single item of type string, it returns a collection with the part of the string starting at position start (zero-based). If length is given, will return at most length number of characters from the input string.
# If start lies outside the length of the string, the function returns an empty collection. If there are less remaining characters in the string than indicated by length, the function returns just the remaining characters.
  - desc: '** substring'
    expression: Functions.coll1.mixed[2].attr.substring(5, 3)
    result: ['str'] 
  

  - desc: '5.6.3. startsWith(prefix : string) : boolean'
# If the input collection contains a single item of type string, the function will return true when the input string starts with the given prefix. Also returns true when prefix is the empty string.
  - desc: '** start with'
    expression: Functions.coll1.mixed[2].attr.startsWith('test')
    result: [true]


  - desc: '5.6.4. endsWith(suffix : string) : boolean'
# If the input collection contains a single item of type string, the function will return true when the input string ends with the given suffix. Also returns true when suffix is the empty string.
  - desc: '** end with'
    expression: Functions.coll1.mixed[2].attr.endsWith('ing')
    result: [true]


  - desc: '5.6.5. contains(substring : string) : boolean'
# If the input collection contains a single item of type string, the function will return true when the given substring is a substring of the input string. Also returns true when substring is the empty string.
  - desc: '** contains'
    expression: Functions.coll1.mixed[2].attr.contains('tri')
    result: [true]



  - desc: '5.6.6. replace(pattern : string, substitution : string) : string'
# If the input collection contains a single item of type string, the function will return the input string with all instances of pattern replaced with substitution. If the substitution is the empty string, the instances of the pattern are removed from the input string. If the pattern is the empty string, every character in the input string is surrounded by the substitution, e.g. 'abc'.replace('','x') becomes 'xaxbxcx'.
  - desc: '** replace'
    expression: Functions.coll1.mixed[2].attr.replace('string', 'lala')
    result: ['test lala']


  - desc: '5.6.7. matches(regex : string) : boolean'
# If the input collection contains a single item of type string, the function will return true when the value matches the given regular expression. Regular expressions should function consistently, regardless of any culture- and locale-specific settings in the environment, should be case-sensitive, use 'single line' mode and allow Unicode characters.
  - desc: '** matches'
    expression: Functions.coll1.mixed[2].attr.matches('t.+')
    result: [true]


  - desc: '5.6.8. replaceMatches(regex : string, substitution: string) : string'
# If the input collection contains a single item of type string, the function will match the input using the regular expression in regex and replace each match with the substitution string. The substitution may refer to identified match groups in the regular expression.
# This example of replace() will convert a string with a date formatted as MM/dd/yy to dd-MM-yy:
# '11/30/1972'.replace('\\b(?<month>\\d{1,2})/(?<day>\\d{1,2})/(?<year>\\d{2,4})\\b',
# '${day}-${month}-${year}')
# Note: Platforms will typically use native regular expression implementations. These are typically fairly similar, but there will always be small differences. As such, FHIRPath does not prescribe a particular dialect, but recommends the use of the dialect defined by as part of XML Schema 1.1 as the dialect most likely to be broadly supported and understood.
  - desc: '** replaceMatches'
    expression: Functions.coll1.mixed[2].attr.replaceMatches('test', 'match')
    result: ['match string']

  - desc: '5.6.9. length() : integer'
# If the input collection contains a single item of type string, the function will return the length of the string. If the input collection is empty ({ }), the result is empty.
  - desc: '** length'
    expression: Functions.coll1.mixed[2].attr.length()
    result: [11]

  - desc: '5.7. Tree navigation'
  - desc: '5.7.1. children() : collection'
# Returns a collection with all immediate child nodes of all items in the input collection. Note that the ordering of the children is undefined and using operations like first() on the result may return different results on different platforms.

  - desc: '** children'
    expression: Functions.coll1.children()
    result: [coll2, coll2, colltrue, collwithfalse. collfalse, collfalse, mixed]

  - desc: '5.7.2. descendants() : collection'
# Returns a collection with all descendant nodes of all items in the input collection. The result does not include the nodes in the input collection themselves. Is a shorthand for repeat(children()). Note that the ordering of the children is undefined and using operations like first() on the result may return different results on different platforms.
# Note: Many of these functions will result in a set of nodes of different underlying types. It may be necessary to use ofType() as described in the previous section to maintain type safety. See section 8 for more information about type safe use of FHIRPath expressions.

  - desc: '** descendants'
    expression: Functions.coll2.descendants()
    result: [1, 2, 3, 4, 5]


  - desc: '5.8. Utility functions'
  - desc: '5.8.1. trace(name : string) : collection'
# Add a string representation of the input collection to the diagnostic log, using the parameter name as the name in the log. This log should be made available to the user in some appropriate fashion. Does not change the input, so returns the input collection as output.

  - desc: '** trace'
    expression: Functions.coll2.attr.trace('coll2')
    result: [1, 2, 3, 4, 5]

  - desc: '5.8.2. today() : dateTime'
# Returns a dateTime containing the current date.

  - desc: '** today()'
    expression: Functions.today()
    result: '1234'


  - desc: '5.8.3. now() : dateTime'
# Returns a dateTime containing the current date and time, including timezone.

  - desc: '** now()'
    expression: now()
    result: '10:10'


subject:
  resourceType: Functions
  attrempty: []
  attrtrue: true
  attrfalse: false
  attrsingle:
    - 1
  attrdouble:
    - 1
    - 2
  attrobject:
    a: 1
    b: 2
  coll1:
    - coll2:
        - attr: 1
        - attr: 2
        - attr: 3
    - coll2:
        - attr: 4
        - attr: 5
    - colltrue:
        - attr: true
        - attr: true
        - attr: true
    - collwithfalse:
        - attr: false
        - attr: true
    - collfalse:
        - attr: false
        - attr: false
    - mixed:
        - attr: true
        - attr: false
        - attr: 'test string'
        - attr: 999
        - attr: 3.14159
        - attr: '@2015-02-04T14:34:28Z'
        - attr: '@T14:34:28+09:00'
        - attr: 4 days
